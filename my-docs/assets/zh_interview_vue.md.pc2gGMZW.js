import{_ as s,c as n,o as a,R as t}from"./chunks/framework.NkhF8npB.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"zh/interview/vue.md","filePath":"zh/interview/vue.md","lastUpdated":1754466630000}'),l={name:"zh/interview/vue.md"},e=t(`<h2 id="_1-vue-生命周期分别做了什么事情" tabindex="-1">1.Vue 生命周期分别做了什么事情 <a class="header-anchor" href="#_1-vue-生命周期分别做了什么事情" aria-label="Permalink to &quot;1.Vue 生命周期分别做了什么事情&quot;">​</a></h2><table><thead><tr><th style="text-align:center;">hooks</th><th style="text-align:center;">status</th><th style="text-align:center;">实践</th></tr></thead><tbody><tr><td style="text-align:center;">beforeCreate</td><td style="text-align:center;">实例初始化之后，this 指向创建的实例，此时不能访问到 data、methods 等属性</td><td style="text-align:center;">常用于初始化非响应式变量</td></tr><tr><td style="text-align:center;">created</td><td style="text-align:center;">实例创建完成，此时可访问 data、method 等属性；不能访问到$el，无法获取组件实例</td><td style="text-align:center;">常用于简单的 ajax 请求，页面的初始化</td></tr><tr><td style="text-align:center;">beforeMount</td><td style="text-align:center;">在挂载开始之前被调用，进行模版编译，把 template 编译成 render 函数</td><td style="text-align:center;">--</td></tr><tr><td style="text-align:center;">mounted</td><td style="text-align:center;">实例挂载到 DOM 上，此时可以访问$el、$ref，因此可以获取到 DOM 节点</td><td style="text-align:center;">常用于获取 VNode 信息和操作，ajax 请求</td></tr><tr><td style="text-align:center;">beforeUpdate</td><td style="text-align:center;">响应式数据更新时调用，获取的是更新前的 DOM</td><td style="text-align:center;">手动移除已添加的事件监听器量</td></tr><tr><td style="text-align:center;">updated</td><td style="text-align:center;">组件更新后立刻调用，可执行依赖于最新 DOM 的操作</td><td style="text-align:center;">避免在这个钩子函数中操作数据，可能陷入死循环</td></tr><tr><td style="text-align:center;">beforeDestroy</td><td style="text-align:center;">实例销毁之前调用。这一步，实例仍然完全可用，this 仍能获取到实例</td><td style="text-align:center;">常用于销毁定时器、解绑全局事件、销毁插件对象等操作</td></tr><tr><td style="text-align:center;">destroyed</td><td style="text-align:center;">实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</td><td style="text-align:center;">--</td></tr></tbody></table><h2 id="_2-keep-alive-及其生命周期" tabindex="-1">2.keep-alive 及其生命周期 <a class="header-anchor" href="#_2-keep-alive-及其生命周期" aria-label="Permalink to &quot;2.keep-alive 及其生命周期&quot;">​</a></h2><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p><strong>keep-alive</strong> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中</p></div><table><thead><tr><th style="text-align:center;">hooks</th><th style="text-align:center;">status</th></tr></thead><tbody><tr><td style="text-align:center;">activated</td><td style="text-align:center;">在第一次渲染时调用，以及后续每次激活时调用</td></tr><tr><td style="text-align:center;">deactivated</td><td style="text-align:center;">组件停用时调用</td></tr></tbody></table><h2 id="_3-v-for-为什么要加上-key" tabindex="-1">3.v-for 为什么要加上 key <a class="header-anchor" href="#_3-v-for-为什么要加上-key" aria-label="Permalink to &quot;3.v-for 为什么要加上 key&quot;">​</a></h2><div class="warning custom-block"><p class="custom-block-title">提升性能</p><p> ① Vue 通过 diff 算法去比较 VDom 的变化，而 <strong>key</strong> 则为每个 VNode 添加了<strong>唯一标识</strong>，使得 diff 算法可以更高效的比较 VDom 的变化<br>  ② 如果 v-for 用于渲染组件，不提供 key 的话，每次重新渲染都会创建<strong>新的实例</strong>，并销毁旧的。而新的组件实例不会继承原有的状态，因此会造成组件<strong>内部状态丢失</strong>的问题，如输入框中已输入的内容</p></div><div class="tip custom-block"><p class="custom-block-title">为什么不建议用 index 作为 key</p><p> index 有可能会变，起不到<strong>唯一标识</strong>的作用</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">arr</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [</span></span>
<span class="line"><span style="color:#E1E4E8;">	{ age: </span><span style="color:#79B8FF;">18</span><span style="color:#E1E4E8;">, name: </span><span style="color:#9ECBFF;">&#39;vladimir&#39;</span><span style="color:#E1E4E8;"> },</span></span>
<span class="line"><span style="color:#E1E4E8;">	{ age: </span><span style="color:#79B8FF;">19</span><span style="color:#E1E4E8;">, name: </span><span style="color:#9ECBFF;">&#39;screeper&#39;</span><span style="color:#E1E4E8;"> },</span></span>
<span class="line"><span style="color:#E1E4E8;">	{ age: </span><span style="color:#79B8FF;">20</span><span style="color:#E1E4E8;">, name: </span><span style="color:#9ECBFF;">&#39;coder&#39;</span><span style="color:#E1E4E8;"> },</span></span>
<span class="line"><span style="color:#E1E4E8;">	{ age: </span><span style="color:#79B8FF;">24</span><span style="color:#E1E4E8;">, name: </span><span style="color:#9ECBFF;">&#39;ghost&#39;</span><span style="color:#E1E4E8;"> }</span></span>
<span class="line"><span style="color:#E1E4E8;">]</span></span>
<span class="line"><span style="color:#E1E4E8;">arr.</span><span style="color:#B392F0;">unshift</span><span style="color:#E1E4E8;">({ age: </span><span style="color:#79B8FF;">23</span><span style="color:#E1E4E8;">, name: </span><span style="color:#9ECBFF;">&#39;codemaker&#39;</span><span style="color:#E1E4E8;"> })</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">arr</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [</span></span>
<span class="line"><span style="color:#24292E;">	{ age: </span><span style="color:#005CC5;">18</span><span style="color:#24292E;">, name: </span><span style="color:#032F62;">&#39;vladimir&#39;</span><span style="color:#24292E;"> },</span></span>
<span class="line"><span style="color:#24292E;">	{ age: </span><span style="color:#005CC5;">19</span><span style="color:#24292E;">, name: </span><span style="color:#032F62;">&#39;screeper&#39;</span><span style="color:#24292E;"> },</span></span>
<span class="line"><span style="color:#24292E;">	{ age: </span><span style="color:#005CC5;">20</span><span style="color:#24292E;">, name: </span><span style="color:#032F62;">&#39;coder&#39;</span><span style="color:#24292E;"> },</span></span>
<span class="line"><span style="color:#24292E;">	{ age: </span><span style="color:#005CC5;">24</span><span style="color:#24292E;">, name: </span><span style="color:#032F62;">&#39;ghost&#39;</span><span style="color:#24292E;"> }</span></span>
<span class="line"><span style="color:#24292E;">]</span></span>
<span class="line"><span style="color:#24292E;">arr.</span><span style="color:#6F42C1;">unshift</span><span style="color:#24292E;">({ age: </span><span style="color:#005CC5;">23</span><span style="color:#24292E;">, name: </span><span style="color:#032F62;">&#39;codemaker&#39;</span><span style="color:#24292E;"> })</span></span></code></pre></div><p>在数组的头部插入新元素，则原数组的所有 index 值都发生了改变，因此 key 的效果无法达到</p></div><h2 id="_4-谈谈-vue-响应式-和-双向绑定-的原理" tabindex="-1">4.谈谈 Vue 响应式 和 双向绑定 的原理 <a class="header-anchor" href="#_4-谈谈-vue-响应式-和-双向绑定-的原理" aria-label="Permalink to &quot;4.谈谈 Vue 响应式 和 双向绑定 的原理&quot;">​</a></h2><p>当数据发生变化时，对应的视图也随之更新</p><div class="danger custom-block"><p class="custom-block-title">响应式</p><p>响应式一定是：<strong>数据与函数</strong>的绑定，这里的函数一般指的是用到此数据的<strong>渲染函数</strong><br> 此外，计算属性 computed 也是此原理，利用数据与回调函数进行绑定，实现了<strong>数据之间的关联</strong>，关联的桥梁正是<strong>回调函数</strong></p></div><div class="danger custom-block"><p class="custom-block-title">双向绑定</p><p><em>Vue2</em> 基于 <strong>Object.defineProperty</strong>，并结合<strong>发布订阅</strong>模式<br><em>Vue3</em> 基于 <strong>Proxy</strong><br> 已 Vue2 为例，通过遍历 data 对象的所有属性，使其转化为 <strong>getter 和 setter</strong><br> 在 getter 里进行<strong>依赖收集</strong>，即记录用到此变量的所有函数<br> 在 setter 里进行<strong>派发更新</strong>，即运行刚刚记录到的所有渲染函数</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">observe</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">obj</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">for</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> key </span><span style="color:#F97583;">in</span><span style="color:#E1E4E8;"> obj) {</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> internalValue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> obj[key]</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> funcs </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Set</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">		Object.</span><span style="color:#B392F0;">defineProperty</span><span style="color:#E1E4E8;">(obj, key, {</span></span>
<span class="line"><span style="color:#E1E4E8;">			</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> () {</span></span>
<span class="line"><span style="color:#E1E4E8;">				</span><span style="color:#6A737D;">// 依赖收集， 记录：哪个函数用到了此变量</span></span>
<span class="line"><span style="color:#E1E4E8;">				window.__func </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> funcs.</span><span style="color:#B392F0;">add</span><span style="color:#E1E4E8;">(window.__func)</span></span>
<span class="line"><span style="color:#E1E4E8;">				</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> internalValue</span></span>
<span class="line"><span style="color:#E1E4E8;">			},</span></span>
<span class="line"><span style="color:#E1E4E8;">			</span><span style="color:#B392F0;">set</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">val</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">				internalValue </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> val</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">				</span><span style="color:#6A737D;">// 派发更新， 运行：执行所有用到此变量的函数</span></span>
<span class="line"><span style="color:#E1E4E8;">				funcs.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">func</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">					</span><span style="color:#B392F0;">func</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">				})</span></span>
<span class="line"><span style="color:#E1E4E8;">			}</span></span>
<span class="line"><span style="color:#E1E4E8;">		})</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 辅助函数，把函数名记录到全局变量上，方便进行依赖收集</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">autoRun</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#FFAB70;">fn</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">	window.__func </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> fn</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#B392F0;">fn</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">	window.__func </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">observe</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#E36209;">obj</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">for</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> key </span><span style="color:#D73A49;">in</span><span style="color:#24292E;"> obj) {</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> internalValue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> obj[key]</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#D73A49;">let</span><span style="color:#24292E;"> funcs </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Set</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">		Object.</span><span style="color:#6F42C1;">defineProperty</span><span style="color:#24292E;">(obj, key, {</span></span>
<span class="line"><span style="color:#24292E;">			</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> () {</span></span>
<span class="line"><span style="color:#24292E;">				</span><span style="color:#6A737D;">// 依赖收集， 记录：哪个函数用到了此变量</span></span>
<span class="line"><span style="color:#24292E;">				window.__func </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> funcs.</span><span style="color:#6F42C1;">add</span><span style="color:#24292E;">(window.__func)</span></span>
<span class="line"><span style="color:#24292E;">				</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> internalValue</span></span>
<span class="line"><span style="color:#24292E;">			},</span></span>
<span class="line"><span style="color:#24292E;">			</span><span style="color:#6F42C1;">set</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">val</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">				internalValue </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> val</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">				</span><span style="color:#6A737D;">// 派发更新， 运行：执行所有用到此变量的函数</span></span>
<span class="line"><span style="color:#24292E;">				funcs.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(</span><span style="color:#E36209;">func</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">					</span><span style="color:#6F42C1;">func</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">				})</span></span>
<span class="line"><span style="color:#24292E;">			}</span></span>
<span class="line"><span style="color:#24292E;">		})</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 辅助函数，把函数名记录到全局变量上，方便进行依赖收集</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">autoRun</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#E36209;">fn</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">	window.__func </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> fn</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#6F42C1;">fn</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">	window.__func </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div></div><h2 id="_5-proxy-与-defineproperty-的异同-以及-vue3-为什么要用-proxy-替代" tabindex="-1">5. Proxy 与 defineProperty 的异同？以及 Vue3 为什么要用 Proxy 替代？ <a class="header-anchor" href="#_5-proxy-与-defineproperty-的异同-以及-vue3-为什么要用-proxy-替代" aria-label="Permalink to &quot;5. Proxy 与 defineProperty 的异同？以及 Vue3 为什么要用 Proxy 替代？&quot;">​</a></h2><p><em>Proxy 和 defineProperty 都是 JavaScript 中用于拦截和改变对象属性行为的工具</em></p><div class="danger custom-block"><p class="custom-block-title">Proxy</p><p>Proxy 对象用于创建一个对象的代理，从而实现<a href="https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots" target="_blank" rel="noreferrer"><em>基本操作</em></a>的<strong>拦截和自定义</strong>（如属性查找、赋值、枚举、函数调用等）</p><p align="right">----摘自MDN官网</p><p>可见，相比于 defineProperty，Proxy 可以拦截所有的基本操作，包括<em>读取原型</em>和<em>数组</em>的相关处理，即回归到了对象的最初状态<br> 因此，在 Proxy 中重新定义对象的基本操作，即可实现 Vue 中响应式的效果（<strong>依赖收集</strong> 和 <strong>派发更新</strong>）</p></div><div class="warning custom-block"><p class="custom-block-title">defineProperty 是如何处理数组的</p><p>上述提到，defineProperty 其实也是对象的<em>基本操作</em>之一，因此当数组发生改变时，Vue 无法监听到，也就无法执行相关的响应式操作</p><p>因此，在 Vue2 中，对于 data 中定义的数组，修改其继承关系，在数组对象与数组原型之间加入一层自定义对象，在这层对象中重写了数组的全部方法，以此达到监听的效果<br><strong>arr(数组对象) -&gt; 自定义对象(隐式原型对象<em>proto</em>指向数组的显式原型) -&gt; Array.prototype</strong></p></div><p>由此可见，使用 Proxy 使得 Vue3 的响应式更为完整，功能更为强大</p>`,17),p=[e];function o(r,c,y,E,i,d){return a(),n("div",null,p)}const F=s(l,[["render",o]]);export{u as __pageData,F as default};
