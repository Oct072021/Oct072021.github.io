import{_ as s,c as n,o as a,R as l}from"./chunks/framework.B60Tsb3Y.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"zh/js/index.md","filePath":"zh/js/index.md","lastUpdated":1717945594000}'),p={name:"zh/js/index.md"},o=l(`<h2 id="_1-对-js-垃圾回收机制的理解" tabindex="-1">1. 对 JS 垃圾回收机制的理解 <a class="header-anchor" href="#_1-对-js-垃圾回收机制的理解" aria-label="Permalink to &quot;1. 对 JS 垃圾回收机制的理解&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>原理：找到那些不再继续使用的变量，然后释放其占用的内存。垃圾收集机制会按照固定的时间间隔周期性地执行这一操作</p></div><p>最常用的跟踪方法是标记清除，当函数执行完后，就会给局部变量打上“离开环境”的标记（除了闭包），在下一次垃圾回收时间到来时就会清除这一块内存，手动将一个有值的变量赋值为 null，也是让这个值离开环境，也可以释放内存</p><h2 id="_2-事件委托原理" tabindex="-1">2. 事件委托原理 <a class="header-anchor" href="#_2-事件委托原理" aria-label="Permalink to &quot;2. 事件委托原理&quot;">​</a></h2><p>利用事件冒泡，让子元素所执行的事件，让其父元素代替执行</p><h2 id="_3-null-和-undefined-的区别" tabindex="-1">3. null 和 undefined 的区别 <a class="header-anchor" href="#_3-null-和-undefined-的区别" aria-label="Permalink to &quot;3. null 和 undefined 的区别&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>null 是一个表示&quot;无&quot;的对象，转为数值时为 0；undefined 是一个表示&quot;无&quot;的原始值，转为数值时为 NaN<br> 当声明的变量还未被初始化时，变量的默认值为 undefined。 null 用来表示尚未存在的对象</p></div><p><strong>undefined</strong> 表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义</p><div class="tip custom-block"><p class="custom-block-title">典型用法</p><p>（1）变量被声明了，但没有赋值时，就等于 undefined<br> （2）调用函数时，应该提供的参数没有提供，该参数等于 undefined<br> （3）对象没有赋值的属性，该属性的值为 undefined<br> （4）函数没有返回值时，默认返回 undefined</p></div><p><strong>null</strong> 表示&quot;没有对象&quot;，即该处不应该有值</p><div class="tip custom-block"><p class="custom-block-title">典型用法</p><p>（1） 作为函数的参数，表示该函数的参数不是对象<br> （2） 作为对象原型链的终点</p></div><h2 id="_4-new-操作符具体做了什么" tabindex="-1">4. new 操作符具体做了什么 <a class="header-anchor" href="#_4-new-操作符具体做了什么" aria-label="Permalink to &quot;4. new 操作符具体做了什么&quot;">​</a></h2><p>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型<br> 2、属性和方法被加入到 this 引用的对象中<br> 3、新创建的对象由 this 所引用，并且最后隐式的返回 this</p><h2 id="_5-谈谈闭包" tabindex="-1">5. 谈谈闭包 <a class="header-anchor" href="#_5-谈谈闭包" aria-label="Permalink to &quot;5. 谈谈闭包&quot;">​</a></h2><p>首先闭包是函数内部再嵌套一层函数，并且嵌套的函数必须要使用到外层函数定义的变量，当执行外层函数时，闭包形成。</p><div class="tip custom-block"><p class="custom-block-title">核心作用</p><p>使变量可以保留在内存中，不被释放掉。也因为如此，可能会造成内存泄漏</p></div><h2 id="_6-谈谈-promise" tabindex="-1">6. 谈谈 Promise <a class="header-anchor" href="#_6-谈谈-promise" aria-label="Permalink to &quot;6. 谈谈 Promise&quot;">​</a></h2><p>（1）promise 是为解决异步处理回调地狱问题而产生的<br> （2）有三种状态，pengding、resolve、reject，状态一旦决定就不会改变<br> （3）then 接收 resolve()，catch 接收 reject()</p><h2 id="_7-js-判断数据类型" tabindex="-1">7.JS 判断数据类型 <a class="header-anchor" href="#_7-js-判断数据类型" aria-label="Permalink to &quot;7.JS 判断数据类型&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">typeof</p><p>能判断出四种，分别是 number，string，boolean，object，剩余的均被检测为 object</p></div><div class="tip custom-block"><p class="custom-block-title">instanceof</p><p>判断参照对象的 prototype 属性所指向的对象是否在被行测对象的原型链上</p></div><div class="tip custom-block"><p class="custom-block-title">constructor</p><p>针对于 instanceof 的弊端，我们使用 constructor 检测，constructor 是原型对象的属性指向构造函数<br> 这种方式解决了 instanceof 的弊端,可以检测出除了 undefined 和 null 的 9 种类型</p></div><div class="tip custom-block"><p class="custom-block-title">Object.prototype.toString.call</p><p>Object.prototype.toString 可以取得对象的内部属性[[class]]，并根据这个内部属性返回诸如&quot;[object Number]&quot;的字符串，那么我们就可以通过 call 获取内部属性[[class]]</p></div><h2 id="_8-ts-中-type-和-interface-的异同" tabindex="-1">8.TS 中 type 和 interface 的异同 <a class="header-anchor" href="#_8-ts-中-type-和-interface-的异同" aria-label="Permalink to &quot;8.TS 中 type 和 interface 的异同&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">相同点</p><ol><li>都可以描述一个对象或函数</li><li>都允许扩展(extends),interface 使用 extends，type 使用等号（=）</li></ol></div><div class="tip custom-block"><p class="custom-block-title">不同点</p><ol start="3"><li>type 可以声明基本类型别名，联合类型，元组等，interface 则不能</li><li>interface 可以合并（覆写），type 不能</li></ol></div><h2 id="_9-call、bind、apply-的作用和区别" tabindex="-1">9.call、bind、apply 的作用和区别 <a class="header-anchor" href="#_9-call、bind、apply-的作用和区别" aria-label="Permalink to &quot;9.call、bind、apply 的作用和区别&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">fn.</span><span style="color:#B392F0;">apply</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, [args_array])</span></span>
<span class="line"><span style="color:#E1E4E8;">fn.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, arg1, arg2, </span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">fn.</span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, arg1, arg2, </span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">)()</span></span>
<span class="line"><span style="color:#E1E4E8;">or</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">newFn</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> fn.</span><span style="color:#B392F0;">bind</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">, arg1, arg2, </span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">fn.</span><span style="color:#6F42C1;">apply</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, [args_array])</span></span>
<span class="line"><span style="color:#24292E;">fn.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, arg1, arg2, </span><span style="color:#D73A49;">...</span><span style="color:#24292E;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">fn.</span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, arg1, arg2, </span><span style="color:#D73A49;">...</span><span style="color:#24292E;">)()</span></span>
<span class="line"><span style="color:#24292E;">or</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">newFn</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> fn.</span><span style="color:#6F42C1;">bind</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">this</span><span style="color:#24292E;">, arg1, arg2, </span><span style="color:#D73A49;">...</span><span style="color:#24292E;">)</span></span></code></pre></div><p> call 和 apply<br> 都可以改变 this 的指向，并且改变后<strong>立即执行</strong>，因此是<strong>临时改变</strong><br> 但传参方式有所不同<br>  bind<br> bind 的返回值是一个函数，此函数已经改变了 this 指向，因此是<strong>永久更改</strong><br> 不会立即执行，需要手动调用</p></div><h2 id="_10-谈谈-es6-的箭头函数" tabindex="-1">10.谈谈 ES6 的箭头函数 <a class="header-anchor" href="#_10-谈谈-es6-的箭头函数" aria-label="Permalink to &quot;10.谈谈 ES6 的箭头函数&quot;">​</a></h2><p>消除了普通函数的<strong>二义性</strong></p><div class="tip custom-block"><p class="custom-block-title">普通函数</p><p>既可以通过 () 执行调用，也可以通过 new 调用<br> 因此意义不明，可读性差</p><p>this：有自己的 this 指向，指向<strong>调用者</strong>，即<strong>存在原型</strong></p></div><div class="warning custom-block"><p class="custom-block-title">箭头函数</p><p>无法通过 new 调用，只能作为函数<strong>执行调用</strong>，意义明确</p><p>this：没有自己的 this，使用的是<strong>父级作用域的 this</strong>，即<strong>不存在原型</strong></p></div><h2 id="_11-js-高阶函数-函数柯里化" tabindex="-1">11. js 高阶函数? 函数柯里化？ <a class="header-anchor" href="#_11-js-高阶函数-函数柯里化" aria-label="Permalink to &quot;11. js 高阶函数? 函数柯里化？&quot;">​</a></h2><div class="danger custom-block"><p class="custom-block-title">函数的本质</p><p><em>对流程的封装，使其具有通用性</em></p></div><p>先看一个普通的例子，createMap()作用是把数组的每一项翻指定的倍数</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">arr1</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> [</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">, </span><span style="color:#79B8FF;">6</span><span style="color:#E1E4E8;">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createMap</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">arr</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">rate</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">newArr</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> []</span></span>
<span class="line"><span style="color:#E1E4E8;">	arr.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">item</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">		newArr.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(item </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> rate)</span></span>
<span class="line"><span style="color:#E1E4E8;">	})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> newArr</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">createMap</span><span style="color:#E1E4E8;">(arr1, </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">))</span></span>
<span class="line"><span style="color:#6A737D;">// [ 2, 4, 6, 12 ]</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">arr1</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> [</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">3</span><span style="color:#24292E;">, </span><span style="color:#005CC5;">6</span><span style="color:#24292E;">]</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createMap</span><span style="color:#24292E;">(</span><span style="color:#E36209;">arr</span><span style="color:#24292E;">, </span><span style="color:#E36209;">rate</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">newArr</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> []</span></span>
<span class="line"><span style="color:#24292E;">	arr.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(</span><span style="color:#E36209;">item</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">		newArr.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(item </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> rate)</span></span>
<span class="line"><span style="color:#24292E;">	})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> newArr</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">createMap</span><span style="color:#24292E;">(arr1, </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">))</span></span>
<span class="line"><span style="color:#6A737D;">// [ 2, 4, 6, 12 ]</span></span></code></pre></div><p>假如需要把数组的每一项转换成指定的格式，比如{ name: name[item] }，显然 rate 不适用</p><h1 align="center">↓</h1><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark has-highlighted-lines vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createMap</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">arr</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">mapper</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">newArr</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> []</span></span>
<span class="line"><span style="color:#E1E4E8;">	arr.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">item</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">		newArr.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">mapper</span><span style="color:#E1E4E8;">(item))</span></span>
<span class="line"><span style="color:#E1E4E8;">	})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> newArr</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">createMap</span><span style="color:#E1E4E8;">(arr1, </span><span style="color:#FFAB70;">n</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> n </span><span style="color:#F97583;">*</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">)) </span><span style="color:#6A737D;">// [ 2, 4, 6, 12 ]</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">createMap</span><span style="color:#E1E4E8;">(arr1, </span><span style="color:#FFAB70;">n</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> ({ name: </span><span style="color:#9ECBFF;">\`name\${</span><span style="color:#E1E4E8;">n</span><span style="color:#9ECBFF;">}\`</span><span style="color:#E1E4E8;"> })))</span></span>
<span class="line"><span style="color:#6A737D;">// [</span></span>
<span class="line"><span style="color:#6A737D;">//   { name: &#39;name1&#39; },</span></span>
<span class="line"><span style="color:#6A737D;">//   { name: &#39;name2&#39; },</span></span>
<span class="line"><span style="color:#6A737D;">//   { name: &#39;name3&#39; },</span></span>
<span class="line"><span style="color:#6A737D;">//   { name: &#39;name6&#39; }</span></span>
<span class="line"><span style="color:#6A737D;">// ]</span></span></code></pre><pre class="shiki github-light has-highlighted-lines vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createMap</span><span style="color:#24292E;">(</span><span style="color:#E36209;">arr</span><span style="color:#24292E;">, </span><span style="color:#E36209;">mapper</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">newArr</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> []</span></span>
<span class="line"><span style="color:#24292E;">	arr.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(</span><span style="color:#E36209;">item</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line highlighted"><span style="color:#24292E;">		newArr.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">mapper</span><span style="color:#24292E;">(item))</span></span>
<span class="line"><span style="color:#24292E;">	})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> newArr</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">createMap</span><span style="color:#24292E;">(arr1, </span><span style="color:#E36209;">n</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> n </span><span style="color:#D73A49;">*</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2</span><span style="color:#24292E;">)) </span><span style="color:#6A737D;">// [ 2, 4, 6, 12 ]</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">createMap</span><span style="color:#24292E;">(arr1, </span><span style="color:#E36209;">n</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> ({ name: </span><span style="color:#032F62;">\`name\${</span><span style="color:#24292E;">n</span><span style="color:#032F62;">}\`</span><span style="color:#24292E;"> })))</span></span>
<span class="line"><span style="color:#6A737D;">// [</span></span>
<span class="line"><span style="color:#6A737D;">//   { name: &#39;name1&#39; },</span></span>
<span class="line"><span style="color:#6A737D;">//   { name: &#39;name2&#39; },</span></span>
<span class="line"><span style="color:#6A737D;">//   { name: &#39;name3&#39; },</span></span>
<span class="line"><span style="color:#6A737D;">//   { name: &#39;name6&#39; }</span></span>
<span class="line"><span style="color:#6A737D;">// ]</span></span></code></pre></div><h1 align="center">↓</h1><h4 align="center">函数柯里化写法</h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark has-highlighted-lines vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createMap</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">arr</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">mapper</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">newArr</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> []</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">		arr.</span><span style="color:#B392F0;">forEach</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">item</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">			newArr.</span><span style="color:#B392F0;">push</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">mapper</span><span style="color:#E1E4E8;">(item))</span></span>
<span class="line highlighted"><span style="color:#E1E4E8;">		})</span></span>
<span class="line highlighted"><wbr></span>
<span class="line highlighted"><span style="color:#E1E4E8;">		</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> newArr</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">newArr</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">createMap</span><span style="color:#E1E4E8;">(arr1)(</span><span style="color:#FFAB70;">n</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> ({ id: n }))</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(newArr) </span><span style="color:#6A737D;">// [ { id: 1 }, { id: 2 }, { id: 3 }, { id: 6 } ]</span></span></code></pre><pre class="shiki github-light has-highlighted-lines vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createMap</span><span style="color:#24292E;">(</span><span style="color:#E36209;">arr</span><span style="color:#24292E;">) {</span></span>
<span class="line highlighted"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">function</span><span style="color:#24292E;"> (</span><span style="color:#E36209;">mapper</span><span style="color:#24292E;">) {</span></span>
<span class="line highlighted"><span style="color:#24292E;">		</span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">newArr</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> []</span></span>
<span class="line highlighted"><span style="color:#24292E;">		arr.</span><span style="color:#6F42C1;">forEach</span><span style="color:#24292E;">(</span><span style="color:#E36209;">item</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line highlighted"><span style="color:#24292E;">			newArr.</span><span style="color:#6F42C1;">push</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">mapper</span><span style="color:#24292E;">(item))</span></span>
<span class="line highlighted"><span style="color:#24292E;">		})</span></span>
<span class="line highlighted"><wbr></span>
<span class="line highlighted"><span style="color:#24292E;">		</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> newArr</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">newArr</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">createMap</span><span style="color:#24292E;">(arr1)(</span><span style="color:#E36209;">n</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> ({ id: n }))</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(newArr) </span><span style="color:#6A737D;">// [ { id: 1 }, { id: 2 }, { id: 3 }, { id: 6 } ]</span></span></code></pre></div><p><strong>柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术</strong></p><div class="warning custom-block"><p class="custom-block-title">实现思路</p><p>判断当前传入函数的参数个数 (args.length) 是否大于等于原函数所需参数个数 (fn.length) ，如果是，则执行当前函数；如果是小于，则返回一个函数</p></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">curry</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">fn</span><span style="color:#E1E4E8;">, </span><span style="color:#F97583;">...</span><span style="color:#FFAB70;">args</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> args.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&gt;=</span><span style="color:#E1E4E8;"> fn.</span><span style="color:#79B8FF;">length</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">?</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">fn</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">args) </span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">...</span><span style="color:#FFAB70;">_args</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">curry</span><span style="color:#E1E4E8;">(fn, </span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">args, </span><span style="color:#F97583;">...</span><span style="color:#E1E4E8;">_args)</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">curry</span><span style="color:#24292E;">(</span><span style="color:#E36209;">fn</span><span style="color:#24292E;">, </span><span style="color:#D73A49;">...</span><span style="color:#E36209;">args</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> args.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&gt;=</span><span style="color:#24292E;"> fn.</span><span style="color:#005CC5;">length</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">?</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">fn</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">...</span><span style="color:#24292E;">args) </span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">...</span><span style="color:#E36209;">_args</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">curry</span><span style="color:#24292E;">(fn, </span><span style="color:#D73A49;">...</span><span style="color:#24292E;">args, </span><span style="color:#D73A49;">...</span><span style="color:#24292E;">_args)</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">函数柯里化的优点</p><p>  函数更加灵活和可重用。通过柯里化，可以将一个多参数的函数转换为一系列单参数的函数，使函数更加灵活和可重用<br>   可以避免重复的代码。通过柯里化，可以避免在调用函数时重复地传递参数，从而避免了重复的代码</p></div><div class="tip custom-block"><p class="custom-block-title">函数柯里化的缺点</p><p>  可能会降低性能。通过柯里化，函数的性能可能会降低，因为需要额外的内存来存储函数的返回值和参数<br>   可能会增加代码复杂度。通过柯里化，可能会增加代码的复杂度，因为需要处理额外的参数和函数返回值</p></div>`,47),e=[o];function t(c,r,E,y,i,d){return a(),n("div",null,e)}const F=s(p,[["render",t]]);export{g as __pageData,F as default};
