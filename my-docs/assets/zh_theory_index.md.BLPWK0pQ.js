import{_ as s,c as t,o,R as e,a1 as a,a2 as r,a3 as i,a4 as n}from"./chunks/framework.Bfjd7Qtw.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"zh/theory/index.md","filePath":"zh/theory/index.md","lastUpdated":1717222572000}'),l={name:"zh/theory/index.md"},c=e('<h2 id="_1-进程-线程" tabindex="-1">1.进程？线程？ <a class="header-anchor" href="#_1-进程-线程" aria-label="Permalink to &quot;1.进程？线程？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">进程</p><p>运行状态的程序需要有自己专属的内存空间，这块空间可以理解为进程<br> 每个应用至少有一个进程，进程之间相互独立，即使需要通信，也要经过双方进程的同意</p></div><div class="tip custom-block"><p class="custom-block-title">线程</p><p>有了进程之后，就可以运行程序的代码了。运行代码的单位，称之为‘线程’<br> 一个进程至少有一个线程，所以当开启进程之后会自动创建一个线程来执行代码，这个线程称之为‘主线程’，如果程序需要同时执行多块代码，主线程就会启动更多线程来执行代码，所以一个进程可以拥有多个线程</p></div><h2 id="_2-浏览器有哪些进程和线程" tabindex="-1">2.浏览器有哪些进程和线程 <a class="header-anchor" href="#_2-浏览器有哪些进程和线程" aria-label="Permalink to &quot;2.浏览器有哪些进程和线程&quot;">​</a></h2><p>  浏览器是一个多进程多线程的应用程序，为了避免相互影响，减少连环崩溃的概率，当启动浏览器后，会自动启动多个进程<br> 其中最主要的进程有：</p><div class="tip custom-block"><p class="custom-block-title">浏览器进程</p><p>主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务</p></div><div class="tip custom-block"><p class="custom-block-title">网络进程</p><p>负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务</p></div><div class="tip custom-block"><p class="custom-block-title">渲染进程：</p><p>渲染进程启动后，会开启一个渲染主线程，主要负责执行 HTML、CSS、JS 代码。默认情况下，浏览器会为每一个标签页开启一个渲染进程，以保证每个标签页之前相互独立</p></div><h2 id="_3-事件循环机制" tabindex="-1">3.事件循环机制 <a class="header-anchor" href="#_3-事件循环机制" aria-label="Permalink to &quot;3.事件循环机制&quot;">​</a></h2><p>  渲染主线程需要处理许多任务，任务调度是一个难题，因此渲染主线程使用‘排队’策略来解决这个难题，此过程则称为“事件循环”</p><div class="danger custom-block"><p class="custom-block-title">DANGER</p><ol><li>在最开始的时候，渲染主线程会进入一个无限循环</li><li>每一次循环会优先检测<strong>微队列</strong>中是否有任务存在。如果有，就取出第一个任务执行，执行完一个进入下一次事件循环；若微队列为空，则检测其他队列是否存在任务，浏览器<strong>自行决定</strong>取哪一个队列的任务执行；如果没有，则进入休眠状态</li><li>其他所有线程（包括其他进程的线程）可以随时向各个消息队列添加任务。新任务会加入到各队列的末尾，在添加新任务时，如果主线程时休眠状态，则会唤醒以继续循环拿取任务</li></ol></div><h2 id="_4-如何理解-js-的异步" tabindex="-1">4.如何理解 JS 的异步 <a class="header-anchor" href="#_4-如何理解-js-的异步" aria-label="Permalink to &quot;4.如何理解 JS 的异步&quot;">​</a></h2><p>  首先 JS 是一门<strong>单线程语言</strong>，这是因为他运行在浏览器的渲染主线程中，而渲染主线程只有一个。渲染主线程承担着许多工作，例如渲染页面、执行 JS 代码</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的渲染主线程白白消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象<br><strong>所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事件传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行</strong></p></div><p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的执行流畅</p><h2 id="_5-浏览器是如何渲染页面的" tabindex="-1">5.浏览器是如何渲染页面的? <a class="header-anchor" href="#_5-浏览器是如何渲染页面的" aria-label="Permalink to &quot;5.浏览器是如何渲染页面的?&quot;">​</a></h2><p>  当浏览器的网络线程接收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。在事件循环机制的作用下，渲染主线程取出消息队列的渲染任务，开启渲染流程。渲染流程分为：</p><p align="center"><img width="800" src="'+a+'"></p><div class="warning custom-block"><p class="custom-block-title">过程详情</p><p>（1） HTML 解析<br>   解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和外部的 JS 文件<br>   如果主线程解析到 link 位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在<strong>预解析线程</strong>中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因<br>   如果主线程解析到 script 位置，会<strong>停止解析 HTML</strong>，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会<strong>修改当前的 DOM 树</strong>，所以 DOM 树的生成必须暂停。这就是 JS 会<strong>阻塞</strong> HTML 解析的根本原因<br>   第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中<br> （2） 样式计算<br>   主线程会遍历得到的 DOM 树，依次为树中的每个节点<strong>计算出它最终的样式</strong><br>   在这一过程中，很多预设值会变成绝对值，比如 red 会变成 rgb(255,0,0);相对单位会变成绝对单位，比如 em 会变成 px<br>   这一步完成后，会得到一棵带有样式的 DOM 树<br> （3） 布局<br>   布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的<strong>几何信息</strong>。例如节点的宽高、相对包含块的位置;大部分时候，<strong>DOM 树和布局树并非一一对应</strong><br>   比如 display:none 的节点没有几何信息，因此不会生成到布局树;又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法―—对应<br> （4） 分层<br>   主线程会使用一套复杂的策略对整个布局树中进行分层<br>   分层的好处在于，将来某一个层改变后，仅会对<strong>该层进行后续处理</strong>，从而提升效率。   滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过 <strong>will-change</strong> 属性更大程度的影响分层结果<br> （5） 绘制<br>   主线程会为每一层单独产生绘制指令集，用于描述这一层的内容该如何画出来<br> （6） 分块<br>   完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成<br>   合成线程首先对每个图层进行分块,将其划分为更多的小区域。它会从线程池中拿取多个线程来完成分块工作<br> （7） 光栅化<br>   分块完成后，进入光栅化阶段<br>   合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化<br>   GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块<br>   光栅化的结果，就是一块一块的位图<br> （8） 画<br>   合成线程拿到每个层、每个块的位图后，生成一个个「指引 (quad)」信息。指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。变形发生在合成线程，与渲染主线程无关，这就是 transform 效率高的本质原因<br>   合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像</p></div><h2 id="_6-重绘-重排" tabindex="-1">6.重绘？重排？ <a class="header-anchor" href="#_6-重绘-重排" aria-label="Permalink to &quot;6.重绘？重排？&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">重排/回流 reflow</p><p>本质: 重新计算<strong>layout</strong>树<br>   当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以,改动属性造成的 reflow 是异步完成的<br>   也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。浏览器在反复权衡下,最终决定获取属性立即 reflow。</p></div><div class="tip custom-block"><p class="custom-block-title">重绘 repaint</p><p>本质: 重新根据分层信息计算了绘制指令<br>   当改动了可见样式后，就需要重新计算,会引发 repaint。由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p></div><h2 id="_7-sessionstorage-的跨标签通信" tabindex="-1">7.sessionStorage 的跨标签通信 <a class="header-anchor" href="#_7-sessionstorage-的跨标签通信" aria-label="Permalink to &quot;7.sessionStorage 的跨标签通信&quot;">​</a></h2><p>sessionStorage 可以进行跨标签通信，但存在一定的局限<br><strong>首先，sessionStorage 是会话级别的存储</strong></p><div class="warning custom-block"><p class="custom-block-title">如何定义一个会话</p><p>关键在于两个标签是否存在联系，比如<br> 在 A 页面点击超链接或者在控制台通过 window.open 打开 B 页面，都属于当前页面的延续，因此属于一个会话<br> 在 A 页面已经打开的前提下，然后在 tab 打开同域 C 页面，此时 A 和 C 无直接关系，因此不属于一个会话</p></div><p>因此，session 并不是共享的，而是<strong>复制</strong>的</p><p>总结来说，B 页面打开的时候复制了 A 页面的 session(可以理解为深拷贝)，因此二者相互独立，互不影响</p><h2 id="_8-单点登录" tabindex="-1">8. 单点登录 <a class="header-anchor" href="#_8-单点登录" aria-label="Permalink to &quot;8. 单点登录&quot;">​</a></h2><p>实际上就是<strong>业务的抽离</strong>，产品线很多的情况下，可以把用户系统抽离出来，形成一个<strong>认证中心</strong>。<br> 如此一来，对用户信息的所有操作，都在此认证中心完成</p><p>技术实现一般为两种：<em>Session + Cookie</em> 模式 &amp;&amp; <em>Token</em> 模式 &amp;&amp; <em>Token + RefreshToken</em> 模式</p><div class="warning custom-block"><p class="custom-block-title">Session + Cookie</p><img src="'+r+'"><p>① 登录，向认证中心验证<br> ② 验证成功后，认证中心往 <em>Session</em> 表格中记录(<strong>key：sid，value：info</strong>)<br> ③ 以 <em>Cookie</em> 形式返回<strong>sid</strong>，即保存在用户浏览器的 <em>Cookie</em> 中<br> ④ 访问子系统时，把此 <strong>sid</strong> 一同带给子系统<br> ⑤ 子系统把 <strong>sid</strong> 发给认证中心，认证中心在 <em>Session</em> 表中查询是否存在相应数据<br> ⑥ 存在结果则校验通过，反之失败</p><div class="danger custom-block"><p class="custom-block-title">分析</p><div style="display:flex;align-items:center;"><span style="width:80px;font-weight:600;">优势 =&gt; </span><span>由于所有系统都需要通过认证中心进行校验，因此认证中心具有非常强的控制力，只需在认证中心操作，即可实现对所有子系统用户的控制</span></div><div style="display:flex;align-items:center;"><span style="width:55px;font-weight:600;">劣势 =&gt; </span><span> 1)费用较高，总用户量或某个子系统的用户量爆发性增大，都需要对认证中心进行扩容<br> 2)容错较低，如果认证中心挂掉，所有子系统都会受影响 </span></div></div></div><div class="warning custom-block"><p class="custom-block-title">Token</p><img src="'+i+'"><p>① 登录，向认证中心验证<br> ② 认证成功后，返回 Token<br> ③ 用户存入 Token，并带着 Token 访问子系统<br> ④ 子系统通过特定的方式(秘钥、特定的加解密算法)验证 Token</p><div class="danger custom-block"><p class="custom-block-title">分析</p><div style="display:flex;align-items:center;"><span style="width:55px;font-weight:600;">优势 =&gt; </span><span>成本较低，认证中心只负责登录操作，不受任何子系统用户量的影响</span></div><div style="display:flex;align-items:center;"><span style="width:55px;font-weight:600;">劣势 =&gt; </span><span>认证中心作用有限，除了登录操作，无法对用户进行任何操作，即失去了对用户的控制</span></div></div></div><h1 align="center">↓ 优化</h1><div class="warning custom-block"><p class="custom-block-title">双 Token</p><img src="'+n+'"><p>① 登录，向认证中心验证<br> ② 认证成功后，返回 Token 和 RefreshToken<br>  (Token 为访问子系统时所携带的，即所有子系统都认识，过期时间较短；RefreshToken 只有认证中心认识，过期时间较长)<br> ③ 用户存入 Token，并带着 Token 访问子系统<br> ④ 子系统通过特定的方式(秘钥、特定的加解密算法)验证 Token<br> ⑤ 若 Token 失效，则子系统提醒用户，用户则带着 RefreshToken 再次请求认证中心，返回新的 Token，然后执行步骤 ③</p><div class="danger custom-block"><p class="custom-block-title">分析</p><p>结合了 <em>Session + Cookie</em> 模式 和 普通 <em>Token</em> 模式，既能实现认证中心对用户的控制，也有效控制了成本<br> 算是一种折中的方案</p></div></div>',34),p=[c];function d(b,m,g,k,h,u){return o(),t("div",null,p)}const S=s(l,[["render",d]]);export{v as __pageData,S as default};
